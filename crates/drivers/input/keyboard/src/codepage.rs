//! Code page support for character encoding
//!
//! Supports various code pages (CP437, CP850, CP1252, UTF-8, etc.)

/// Code page trait for character encoding
pub trait CodePage {
    /// Get the code page identifier (e.g., 437, 850, 1252)
    fn id(&self) -> u16;

    /// Get the code page name
    fn name(&self) -> &'static str;

    /// Convert a Unicode character to the code page byte representation
    fn from_unicode(&self, ch: char) -> Option<u8>;

    /// Convert a code page byte to Unicode character
    fn to_unicode(&self, byte: u8) -> char;
}

/// CP437 - Original IBM PC code page (US English)
pub struct CodePage437;

impl CodePage for CodePage437 {
    fn id(&self) -> u16 {
        437
    }

    fn name(&self) -> &'static str {
        "CP437"
    }

    fn from_unicode(&self, ch: char) -> Option<u8> {
        // ASCII range (0-127) maps directly
        if ch as u32 <= 127 {
            return Some(ch as u8);
        }

        // Extended ASCII characters (128-255)
        let byte = match ch {
            'Ç' => 128, 'ü' => 129, 'é' => 130, 'â' => 131,
            'ä' => 132, 'à' => 133, 'å' => 134, 'ç' => 135,
            'ê' => 136, 'ë' => 137, 'è' => 138, 'ï' => 139,
            'î' => 140, 'ì' => 141, 'Ä' => 142, 'Å' => 143,
            'É' => 144, 'æ' => 145, 'Æ' => 146, 'ô' => 147,
            'ö' => 148, 'ò' => 149, 'û' => 150, 'ù' => 151,
            'ÿ' => 152, 'Ö' => 153, 'Ü' => 154, '¢' => 155,
            '£' => 156, '¥' => 157, '₧' => 158, 'ƒ' => 159,
            'á' => 160, 'í' => 161, 'ó' => 162, 'ú' => 163,
            'ñ' => 164, 'Ñ' => 165, 'ª' => 166, 'º' => 167,
            '¿' => 168, '⌐' => 169, '¬' => 170, '½' => 171,
            '¼' => 172, '¡' => 173, '«' => 174, '»' => 175,
            '░' => 176, '▒' => 177, '▓' => 178, '│' => 179,
            '┤' => 180, '╡' => 181, '╢' => 182, '╖' => 183,
            '╕' => 184, '╣' => 185, '║' => 186, '╗' => 187,
            '╝' => 188, '╜' => 189, '╛' => 190, '┐' => 191,
            '└' => 192, '┴' => 193, '┬' => 194, '├' => 195,
            '─' => 196, '┼' => 197, '╞' => 198, '╟' => 199,
            '╚' => 200, '╔' => 201, '╩' => 202, '╦' => 203,
            '╠' => 204, '═' => 205, '╬' => 206, '╧' => 207,
            '╨' => 208, '╤' => 209, '╥' => 210, '╙' => 211,
            '╘' => 212, '╒' => 213, '╓' => 214, '╫' => 215,
            '╪' => 216, '┘' => 217, '┌' => 218, '█' => 219,
            '▄' => 220, '▌' => 221, '▐' => 222, '▀' => 223,
            'α' => 224, 'ß' => 225, 'Γ' => 226, 'π' => 227,
            'Σ' => 228, 'σ' => 229, 'µ' => 230, 'τ' => 231,
            'Φ' => 232, 'Θ' => 233, 'Ω' => 234, 'δ' => 235,
            '∞' => 236, 'φ' => 237, 'ε' => 238, '∩' => 239,
            '≡' => 240, '±' => 241, '≥' => 242, '≤' => 243,
            '⌠' => 244, '⌡' => 245, '÷' => 246, '≈' => 247,
            '°' => 248, '∙' => 249, '·' => 250, '√' => 251,
            'ⁿ' => 252, '²' => 253, '■' => 254, ' ' => 255,
            _ => return None,
        };
        Some(byte)
    }

    fn to_unicode(&self, byte: u8) -> char {
        if byte <= 127 {
            return byte as char;
        }

        match byte {
            128 => 'Ç', 129 => 'ü', 130 => 'é', 131 => 'â',
            132 => 'ä', 133 => 'à', 134 => 'å', 135 => 'ç',
            136 => 'ê', 137 => 'ë', 138 => 'è', 139 => 'ï',
            140 => 'î', 141 => 'ì', 142 => 'Ä', 143 => 'Å',
            144 => 'É', 145 => 'æ', 146 => 'Æ', 147 => 'ô',
            148 => 'ö', 149 => 'ò', 150 => 'û', 151 => 'ù',
            152 => 'ÿ', 153 => 'Ö', 154 => 'Ü', 155 => '¢',
            156 => '£', 157 => '¥', 158 => '₧', 159 => 'ƒ',
            160 => 'á', 161 => 'í', 162 => 'ó', 163 => 'ú',
            164 => 'ñ', 165 => 'Ñ', 166 => 'ª', 167 => 'º',
            168 => '¿', 169 => '⌐', 170 => '¬', 171 => '½',
            172 => '¼', 173 => '¡', 174 => '«', 175 => '»',
            176 => '░', 177 => '▒', 178 => '▓', 179 => '│',
            180 => '┤', 181 => '╡', 182 => '╢', 183 => '╖',
            184 => '╕', 185 => '╣', 186 => '║', 187 => '╗',
            188 => '╝', 189 => '╜', 190 => '╛', 191 => '┐',
            192 => '└', 193 => '┴', 194 => '┬', 195 => '├',
            196 => '─', 197 => '┼', 198 => '╞', 199 => '╟',
            200 => '╚', 201 => '╔', 202 => '╩', 203 => '╦',
            204 => '╠', 205 => '═', 206 => '╬', 207 => '╧',
            208 => '╨', 209 => '╤', 210 => '╥', 211 => '╙',
            212 => '╘', 213 => '╒', 214 => '╓', 215 => '╫',
            216 => '╪', 217 => '┘', 218 => '┌', 219 => '█',
            220 => '▄', 221 => '▌', 222 => '▐', 223 => '▀',
            224 => 'α', 225 => 'ß', 226 => 'Γ', 227 => 'π',
            228 => 'Σ', 229 => 'σ', 230 => 'µ', 231 => 'τ',
            232 => 'Φ', 233 => 'Θ', 234 => 'Ω', 235 => 'δ',
            236 => '∞', 237 => 'φ', 238 => 'ε', 239 => '∩',
            240 => '≡', 241 => '±', 242 => '≥', 243 => '≤',
            244 => '⌠', 245 => '⌡', 246 => '÷', 247 => '≈',
            248 => '°', 249 => '∙', 250 => '·', 251 => '√',
            252 => 'ⁿ', 253 => '²', 254 => '■', 255 => ' ',
            _ => '?',
        }
    }
}

/// CP850 - Multilingual (Latin 1)
pub struct CodePage850;

impl CodePage for CodePage850 {
    fn id(&self) -> u16 {
        850
    }

    fn name(&self) -> &'static str {
        "CP850"
    }

    fn from_unicode(&self, ch: char) -> Option<u8> {
        if ch as u32 <= 127 {
            return Some(ch as u8);
        }

        let byte = match ch {
            'Ç' => 128, 'ü' => 129, 'é' => 130, 'â' => 131,
            'ä' => 132, 'à' => 133, 'å' => 134, 'ç' => 135,
            'ê' => 136, 'ë' => 137, 'è' => 138, 'ï' => 139,
            'î' => 140, 'ì' => 141, 'Ä' => 142, 'Å' => 143,
            'É' => 144, 'æ' => 145, 'Æ' => 146, 'ô' => 147,
            'ö' => 148, 'ò' => 149, 'û' => 150, 'ù' => 151,
            'ÿ' => 152, 'Ö' => 153, 'Ü' => 154, 'ø' => 155,
            '£' => 156, 'Ø' => 157, '×' => 158, 'ƒ' => 159,
            'á' => 160, 'í' => 161, 'ó' => 162, 'ú' => 163,
            'ñ' => 164, 'Ñ' => 165, 'ª' => 166, 'º' => 167,
            '¿' => 168, '®' => 169, '¬' => 170, '½' => 171,
            '¼' => 172, '¡' => 173, '«' => 174, '»' => 175,
            '░' => 176, '▒' => 177, '▓' => 178, '│' => 179,
            '┤' => 180, 'Á' => 181, 'Â' => 182, 'À' => 183,
            '©' => 184, '╣' => 185, '║' => 186, '╗' => 187,
            '╝' => 188, '¢' => 189, '¥' => 190, '┐' => 191,
            '└' => 192, '┴' => 193, '┬' => 194, '├' => 195,
            '─' => 196, '┼' => 197, 'ã' => 198, 'Ã' => 199,
            '╚' => 200, '╔' => 201, '╩' => 202, '╦' => 203,
            '╠' => 204, '═' => 205, '╬' => 206, '¤' => 207,
            'ð' => 208, 'Ð' => 209, 'Ê' => 210, 'Ë' => 211,
            'È' => 212, 'ı' => 213, 'Í' => 214, 'Î' => 215,
            'Ï' => 216, '┘' => 217, '┌' => 218, '█' => 219,
            '▄' => 220, '¦' => 221, 'Ì' => 222, '▀' => 223,
            'Ó' => 224, 'ß' => 225, 'Ô' => 226, 'Ò' => 227,
            'õ' => 228, 'Õ' => 229, 'µ' => 230, 'þ' => 231,
            'Þ' => 232, 'Ú' => 233, 'Û' => 234, 'Ù' => 235,
            'ý' => 236, 'Ý' => 237, '¯' => 238, '´' => 239,
            '­' => 240, '±' => 241, '‗' => 242, '¾' => 243,
            '¶' => 244, '§' => 245, '÷' => 246, '¸' => 247,
            '°' => 248, '¨' => 249, '·' => 250, '¹' => 251,
            '³' => 252, '²' => 253, '■' => 254, ' ' => 255,
            _ => return None,
        };
        Some(byte)
    }

    fn to_unicode(&self, byte: u8) -> char {
        if byte <= 127 {
            return byte as char;
        }

        match byte {
            128 => 'Ç', 129 => 'ü', 130 => 'é', 131 => 'â',
            132 => 'ä', 133 => 'à', 134 => 'å', 135 => 'ç',
            136 => 'ê', 137 => 'ë', 138 => 'è', 139 => 'ï',
            140 => 'î', 141 => 'ì', 142 => 'Ä', 143 => 'Å',
            144 => 'É', 145 => 'æ', 146 => 'Æ', 147 => 'ô',
            148 => 'ö', 149 => 'ò', 150 => 'û', 151 => 'ù',
            152 => 'ÿ', 153 => 'Ö', 154 => 'Ü', 155 => 'ø',
            156 => '£', 157 => 'Ø', 158 => '×', 159 => 'ƒ',
            160 => 'á', 161 => 'í', 162 => 'ó', 163 => 'ú',
            164 => 'ñ', 165 => 'Ñ', 166 => 'ª', 167 => 'º',
            168 => '¿', 169 => '®', 170 => '¬', 171 => '½',
            172 => '¼', 173 => '¡', 174 => '«', 175 => '»',
            176 => '░', 177 => '▒', 178 => '▓', 179 => '│',
            180 => '┤', 181 => 'Á', 182 => 'Â', 183 => 'À',
            184 => '©', 185 => '╣', 186 => '║', 187 => '╗',
            188 => '╝', 189 => '¢', 190 => '¥', 191 => '┐',
            192 => '└', 193 => '┴', 194 => '┬', 195 => '├',
            196 => '─', 197 => '┼', 198 => 'ã', 199 => 'Ã',
            200 => '╚', 201 => '╔', 202 => '╩', 203 => '╦',
            204 => '╠', 205 => '═', 206 => '╬', 207 => '¤',
            208 => 'ð', 209 => 'Ð', 210 => 'Ê', 211 => 'Ë',
            212 => 'È', 213 => 'ı', 214 => 'Í', 215 => 'Î',
            216 => 'Ï', 217 => '┘', 218 => '┌', 219 => '█',
            220 => '▄', 221 => '¦', 222 => 'Ì', 223 => '▀',
            224 => 'Ó', 225 => 'ß', 226 => 'Ô', 227 => 'Ò',
            228 => 'õ', 229 => 'Õ', 230 => 'µ', 231 => 'þ',
            232 => 'Þ', 233 => 'Ú', 234 => 'Û', 235 => 'Ù',
            236 => 'ý', 237 => 'Ý', 238 => '¯', 239 => '´',
            240 => '­', 241 => '±', 242 => '‗', 243 => '¾',
            244 => '¶', 245 => '§', 246 => '÷', 247 => '¸',
            248 => '°', 249 => '¨', 250 => '·', 251 => '¹',
            252 => '³', 253 => '²', 254 => '■', 255 => ' ',
            _ => '?',
        }
    }
}

/// CP1252 - Windows Latin 1 (Western European)
pub struct CodePage1252;

impl CodePage for CodePage1252 {
    fn id(&self) -> u16 {
        1252
    }

    fn name(&self) -> &'static str {
        "CP1252"
    }

    fn from_unicode(&self, ch: char) -> Option<u8> {
        // ASCII and Latin-1 (0-255) mostly map directly
        let code = ch as u32;

        if code <= 127 || (code >= 160 && code <= 255) {
            return Some(code as u8);
        }

        // Windows-1252 specific mappings (128-159 range)
        let byte = match ch {
            '€' => 128, '‚' => 130, 'ƒ' => 131, '„' => 132,
            '…' => 133, '†' => 134, '‡' => 135, 'ˆ' => 136,
            '‰' => 137, 'Š' => 138, '‹' => 139, 'Œ' => 140,
            'Ž' => 142, '\u{2018}' => 145, '\u{2019}' => 146, '\u{201C}' => 147,
            '\u{201D}' => 148, '•' => 149, '–' => 150, '—' => 151,
            '˜' => 152, '™' => 153, 'š' => 154, '›' => 155,
            'œ' => 156, 'ž' => 158, 'Ÿ' => 159,
            _ => return None,
        };
        Some(byte)
    }

    fn to_unicode(&self, byte: u8) -> char {
        if byte <= 127 || byte >= 160 {
            return byte as char;
        }

        // Windows-1252 specific characters (128-159)
        match byte {
            128 => '€', 130 => '‚', 131 => 'ƒ', 132 => '„',
            133 => '…', 134 => '†', 135 => '‡', 136 => 'ˆ',
            137 => '‰', 138 => 'Š', 139 => '‹', 140 => 'Œ',
            142 => 'Ž', 145 => '\u{2018}', 146 => '\u{2019}', 147 => '"',
            148 => '"', 149 => '•', 150 => '–', 151 => '—',
            152 => '˜', 153 => '™', 154 => 'š', 155 => '›',
            156 => 'œ', 158 => 'ž', 159 => 'Ÿ',
            _ => '?',
        }
    }
}

/// UTF-8 pass-through (for modern systems)
pub struct CodePageUTF8;

impl CodePage for CodePageUTF8 {
    fn id(&self) -> u16 {
        65001  // Windows UTF-8 code page number
    }

    fn name(&self) -> &'static str {
        "UTF-8"
    }

    fn from_unicode(&self, ch: char) -> Option<u8> {
        // UTF-8 doesn't map to single bytes for all characters
        // For ASCII range, return the byte directly
        if (ch as u32) <= 127 {
            Some(ch as u8)
        } else {
            None  // Multi-byte UTF-8 not supported in single-byte interface
        }
    }

    fn to_unicode(&self, byte: u8) -> char {
        // ASCII range maps directly
        if byte <= 127 {
            byte as char
        } else {
            '?'  // Non-ASCII requires multi-byte handling
        }
    }
}
