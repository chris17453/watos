//! Terminal renderer
//!
//! Renders the terminal grid to a framebuffer with:
//! - Bitmap font rendering (8x16)
//! - Dirty cell tracking for efficient updates
//! - Cursor rendering

use crate::cell::{Cell, CellFlags};
use crate::color::Color;
use crate::framebuffer::Framebuffer;
use crate::grid::Grid;

/// Font dimensions
pub const FONT_WIDTH: u32 = 8;
pub const FONT_HEIGHT: u32 = 16;

/// Terminal renderer
pub struct Renderer {
    /// Cursor blink state
    cursor_visible: bool,
    /// Cursor blink counter (unused, kept for ABI compatibility)
    cursor_blink_count: u32,
    /// Frames per cursor blink toggle (unused, kept for ABI compatibility)
    cursor_blink_rate: u32,
    /// Last rendered cursor position (col, row) - for clearing old cursor
    last_cursor_pos: Option<(usize, usize)>,
}

impl Renderer {
    /// Create a new renderer
    pub const fn new() -> Self {
        Self {
            cursor_visible: true,
            cursor_blink_count: 0,
            cursor_blink_rate: 30,
            last_cursor_pos: None,
        }
    }

    /// Render the entire grid to the framebuffer
    pub fn render_full<F: Framebuffer>(&mut self, fb: &mut F, grid: &Grid, cursor: Option<(usize, usize)>) {
        // Clear with background color
        fb.clear(grid.default_bg());

        // Render all cells
        for row in 0..grid.rows() {
            for col in 0..grid.cols() {
                if let Some(cell) = grid.get(col, row) {
                    self.render_cell(fb, col, row, cell);
                }
            }
        }

        // Render cursor
        if let Some((cx, cy)) = cursor {
            if self.cursor_visible {
                self.render_cursor(fb, cx, cy, grid);
            }
        }

        // Track cursor position
        self.last_cursor_pos = cursor;
    }

    /// Render only dirty rows
    pub fn render_dirty<F: Framebuffer>(&mut self, fb: &mut F, grid: &mut Grid, cursor: Option<(usize, usize)>) {
        if grid.needs_full_redraw() {
            self.render_full(fb, grid, cursor);
            self.last_cursor_pos = cursor;
            grid.mark_all_clean();
            return;
        }

        // Clear old cursor position if it changed
        if let Some((old_col, old_row)) = self.last_cursor_pos {
            if cursor != self.last_cursor_pos {
                // Redraw the old cursor cell without cursor
                if let Some(cell) = grid.get(old_col, old_row) {
                    self.render_cell(fb, old_col, old_row, cell);
                }
            }
        }

        // Render dirty rows
        for row in 0..grid.rows() {
            if grid.is_row_dirty(row) {
                for col in 0..grid.cols() {
                    if let Some(cell) = grid.get(col, row) {
                        self.render_cell(fb, col, row, cell);
                    }
                }
                grid.mark_row_clean(row);
            }
        }

        // Render cursor at new position
        if let Some((cx, cy)) = cursor {
            if self.cursor_visible {
                self.render_cursor(fb, cx, cy, grid);
            }
        }

        // Update last cursor position
        self.last_cursor_pos = cursor;
    }

    /// Render a single cell
    pub fn render_cell<F: Framebuffer>(&self, fb: &mut F, col: usize, row: usize, cell: &Cell) {
        let x = col as u32 * FONT_WIDTH;
        let y = row as u32 * FONT_HEIGHT;

        // Get effective colors
        let fg = cell.effective_fg();
        let bg = cell.effective_bg();

        // Fill background
        fb.fill_rect(x, y, FONT_WIDTH, FONT_HEIGHT, bg);

        // Draw character glyph
        if cell.ch != ' ' && !cell.is_wide_spacer() {
            self.draw_glyph(fb, x, y, cell.ch, fg, cell.flags);
        }

        // Draw underline if set
        if cell.flags.contains(CellFlags::UNDERLINE) {
            fb.fill_rect(x, y + FONT_HEIGHT - 1, FONT_WIDTH, 1, fg);
        }

        // Draw strikethrough if set
        if cell.flags.contains(CellFlags::STRIKETHROUGH) {
            fb.fill_rect(x, y + FONT_HEIGHT / 2, FONT_WIDTH, 1, fg);
        }
    }

    /// Draw a character glyph
    fn draw_glyph<F: Framebuffer>(&self, fb: &mut F, x: u32, y: u32, ch: char, fg: Color, flags: CellFlags) {
        let glyph_idx = if (ch as u32) < 256 {
            ch as usize
        } else {
            // Fallback for non-ASCII
            b'?' as usize
        };

        let glyph = &FONT_8X16[glyph_idx];

        for (row, &bits) in glyph.iter().enumerate() {
            let bits = if flags.contains(CellFlags::BOLD) {
                // Bold: OR each pixel with its left neighbor
                bits | (bits >> 1)
            } else {
                bits
            };

            for col in 0..8 {
                if (bits >> (7 - col)) & 1 != 0 {
                    fb.set_pixel(x + col, y + row as u32, fg);
                }
            }
        }
    }

    /// Render cursor at position
    fn render_cursor<F: Framebuffer>(&self, fb: &mut F, col: usize, row: usize, grid: &Grid) {
        let x = col as u32 * FONT_WIDTH;
        let y = row as u32 * FONT_HEIGHT;

        // Get cell at cursor position for color
        let fg = grid.get(col, row)
            .map(|c| c.effective_fg())
            .unwrap_or(Color::WHITE);

        // Draw block cursor (inverted)
        fb.fill_rect(x, y + FONT_HEIGHT - 2, FONT_WIDTH, 2, fg);
    }

    /// Toggle cursor visibility (call this at blink interval)
    pub fn tick_cursor(&mut self) -> bool {
        self.cursor_visible = !self.cursor_visible;
        true // Always returns true since we always toggle
    }

    /// Redraw just the cursor cell (for efficient cursor blinking)
    pub fn render_cursor_cell<F: Framebuffer>(&mut self, fb: &mut F, col: usize, row: usize, grid: &Grid) {
        // Clear old cursor position if different
        if let Some((old_col, old_row)) = self.last_cursor_pos {
            if old_col != col || old_row != row {
                if let Some(cell) = grid.get(old_col, old_row) {
                    self.render_cell(fb, old_col, old_row, cell);
                }
            }
        }

        // Redraw the cell content first
        if let Some(cell) = grid.get(col, row) {
            self.render_cell(fb, col, row, cell);
        }
        // Then draw cursor on top if visible
        if self.cursor_visible {
            self.render_cursor(fb, col, row, grid);
        }

        self.last_cursor_pos = Some((col, row));
    }

    /// Force cursor visible
    pub fn show_cursor(&mut self) {
        self.cursor_visible = true;
        self.cursor_blink_count = 0;
    }

    /// Set cursor blink rate (frames per toggle)
    pub fn set_blink_rate(&mut self, rate: u32) {
        self.cursor_blink_rate = rate;
    }
}

impl Default for Renderer {
    fn default() -> Self {
        Self::new()
    }
}

/// 8x16 VGA font (CP437 compatible)
/// Each character is 16 bytes, one byte per row, MSB is leftmost pixel
pub static FONT_8X16: [[u8; 16]; 256] = {
    let mut font = [[0u8; 16]; 256];

    // Space (32)
    font[32] = [0x00; 16];

    // ! (33)
    font[33] = [0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00];

    // " (34)
    font[34] = [0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // # (35)
    font[35] = [0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00];

    // $ (36)
    font[36] = [0x00, 0x18, 0x18, 0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00];

    // % (37)
    font[37] = [0x00, 0x00, 0x00, 0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // & (38)
    font[38] = [0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00];

    // ' (39)
    font[39] = [0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // ( (40)
    font[40] = [0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00];

    // ) (41)
    font[41] = [0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00];

    // * (42)
    font[42] = [0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // + (43)
    font[43] = [0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // , (44)
    font[44] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00];

    // - (45)
    font[45] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // . (46)
    font[46] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00];

    // / (47)
    font[47] = [0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // 0-9 (48-57)
    font[48] = [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[49] = [0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00];
    font[50] = [0x00, 0x00, 0x3C, 0x66, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x66, 0x7E, 0x00, 0x00, 0x00, 0x00];
    font[51] = [0x00, 0x00, 0x3C, 0x66, 0x06, 0x06, 0x1C, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[52] = [0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00];
    font[53] = [0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[54] = [0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[55] = [0x00, 0x00, 0x7E, 0x66, 0x06, 0x0C, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00];
    font[56] = [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[57] = [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x06, 0x0C, 0x38, 0x00, 0x00, 0x00, 0x00];

    // : (58)
    font[58] = [0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00];

    // ; (59)
    font[59] = [0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00];

    // < (60)
    font[60] = [0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00];

    // = (61)
    font[61] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // > (62)
    font[62] = [0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00];

    // ? (63)
    font[63] = [0x00, 0x00, 0x3C, 0x66, 0x66, 0x06, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00];

    // @ (64)
    font[64] = [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00];

    // A-Z (65-90)
    font[65] = [0x00, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[66] = [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00];
    font[67] = [0x00, 0x00, 0x3C, 0x66, 0x66, 0x60, 0x60, 0x60, 0x60, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[68] = [0x00, 0x00, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00, 0x00, 0x00, 0x00];
    font[69] = [0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00];
    font[70] = [0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00];
    font[71] = [0x00, 0x00, 0x3C, 0x66, 0x66, 0x60, 0x60, 0x6E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00];
    font[72] = [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[73] = [0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[74] = [0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00];
    font[75] = [0x00, 0x00, 0x66, 0x66, 0x6C, 0x6C, 0x78, 0x78, 0x6C, 0x6C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[76] = [0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00];
    font[77] = [0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00];
    font[78] = [0x00, 0x00, 0x66, 0x66, 0x76, 0x76, 0x7E, 0x6E, 0x6E, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[79] = [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[80] = [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00];
    font[81] = [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x76, 0x6C, 0x3C, 0x06, 0x00, 0x00, 0x00];
    font[82] = [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[83] = [0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x3C, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[84] = [0x00, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00];
    font[85] = [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[86] = [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00];
    font[87] = [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xFE, 0xEE, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00];
    font[88] = [0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[89] = [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00];
    font[90] = [0x00, 0x00, 0x7E, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00];

    // [ (91)
    font[91] = [0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00];

    // \ (92)
    font[92] = [0x00, 0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // ] (93)
    font[93] = [0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00];

    // ^ (94)
    font[94] = [0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // _ (95)
    font[95] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00];

    // ` (96)
    font[96] = [0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    // a-z (97-122)
    font[97] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00];
    font[98] = [0x00, 0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00];
    font[99] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[100] = [0x00, 0x00, 0x06, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00];
    font[101] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x7E, 0x60, 0x60, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[102] = [0x00, 0x00, 0x1C, 0x36, 0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00];
    font[103] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00, 0x00];
    font[104] = [0x00, 0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[105] = [0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[106] = [0x00, 0x00, 0x0C, 0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38, 0x00, 0x00];
    font[107] = [0x00, 0x00, 0x60, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[108] = [0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[109] = [0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00];
    font[110] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[111] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[112] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00, 0x00];
    font[113] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x06, 0x00, 0x00];
    font[114] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00];
    font[115] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00];
    font[116] = [0x00, 0x00, 0x30, 0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00];
    font[117] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00];
    font[118] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00];
    font[119] = [0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, 0x00, 0x00, 0x00];
    font[120] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00];
    font[121] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00, 0x00];
    font[122] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00, 0x00, 0x00, 0x00];

    // { (123)
    font[123] = [0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00];

    // | (124)
    font[124] = [0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00];

    // } (125)
    font[125] = [0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00];

    // ~ (126)
    font[126] = [0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    font
};
